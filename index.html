<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pumpkin Candy Collector - Halloween Mini-Game on Somnia</title>
    <style>
        body { 
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f0f23); 
            color: #fff; 
            font-family: 'Segoe UI', Arial, sans-serif; 
            text-align: center;
            margin: 0;
            padding: 20px;
        }
        canvas { 
            border: 3px solid #FF6B35; 
            background: linear-gradient(180deg, #0a0a1a, #1a1a2e);
            cursor: crosshair; 
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
            border-radius: 10px;
        }
        button { 
            background: linear-gradient(45deg, #FF6B35, #F7931E); 
            color: white; 
            padding: 12px 24px; 
            margin: 10px; 
            border: none; 
            cursor: pointer;
            border-radius: 25px;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 53, 0.4);
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #leaderboard { 
            margin-top: 20px; 
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        .game-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            font-size: 18px;
            font-weight: bold;
        }
        .stat-item {
            padding: 10px 20px;
            background: rgba(255, 107, 53, 0.2);
            border-radius: 15px;
            border: 2px solid rgba(255, 107, 53, 0.5);
        }
        h1 {
            color: #FF6B35;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        p {
            font-size: 1.2em;
            color: #cccccc;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body>
    <h1>ðŸŽƒ Pumpkin Rain Collector ðŸŽƒ</h1>
    <p>Click the falling pumpkins to collect candies! Don't let more than 10 fall!</p>
    <canvas id="gameCanvas" width="600" height="500"></canvas>
    <div class="game-stats">
        <div class="stat-item">Score: <span id="score">0</span></div>
        <div class="stat-item">Time: <span id="time">30</span>s</div>
        <div class="stat-item">Missed: <span id="missed">0</span>/10</div>
    </div>
    <button id="startBtn">Start Game</button>
    <button id="connectBtn">Connect Wallet</button>
    <button id="submitBtn" disabled>Submit Score to Somnia</button>
    <div id="status"></div>
    <div id="leaderboard">
        <h2>Leaderboard (Top 5)</h2>
        <ul id="leaderboardList"></ul>
    </div>

    <script>
        const CONTRACT_ADDRESS = '0x2f4016FBD38e9e2E54043154F04995bD13CE7db2'; // Replace with your deployed address
        const CONTRACT_ABI = [
            {"inputs":[{"internalType":"uint256","name":"_score","type":"uint256"}],"name":"submitScore","outputs":[],"stateMutability":"nonpayable","type":"function"},
            {"inputs":[{"internalType":"address","name":"_player","type":"address"}],"name":"getScore","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"_limit","type":"uint256"}],"name":"getLeaderboard","outputs":[{"internalType":"address[]","name":"","type":"address[]"},{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];

        let provider, signer, contract;
        let score = 0;
        let missed = 0;
        let time = 30;
        let gameRunning = false;
        let gameLoop;
        let pumpkins = [];
        let lastPumpkinSpawn = 0;
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const connectBtn = document.getElementById('connectBtn');
        const submitBtn = document.getElementById('submitBtn');
        const status = document.getElementById('status');
        const leaderboardList = document.getElementById('leaderboardList');

        // Game settings
        const PUMPKIN_SIZE = 40;
        let PUMPKIN_SPEED = 2;
        let SPAWN_RATE = 1200; // milliseconds
        const MAX_MISSED = 10;
        let difficultyLevel = 1;

        // Difficulty progression
        function updateDifficulty() {
            const newLevel = Math.floor(score / 10) + 1;
            if (newLevel > difficultyLevel) {
                difficultyLevel = newLevel;
                PUMPKIN_SPEED = Math.min(2 + (difficultyLevel - 1) * 0.5, 6);
                SPAWN_RATE = Math.max(1200 - (difficultyLevel - 1) * 150, 400);
                
                // Show difficulty increase notification
                status.innerText = `Difficulty increased! Level ${difficultyLevel}`;
                setTimeout(() => {
                    if (gameRunning) status.innerText = '';
                }, 2000);
            }
        }

        // Somnia Mainnet Config
        const somniaProvider = new ethers.providers.JsonRpcProvider('https://api.infra.mainnet.somnia.network/');

        // Pumpkin class
        class Pumpkin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = PUMPKIN_SIZE;
                this.speed = PUMPKIN_SPEED + Math.random() * 2; // Random speed variation
                this.clicked = false;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            }

            update() {
                this.y += this.speed;
                this.rotation += this.rotationSpeed;
                
                // Check if pumpkin fell off screen
                if (this.y > canvas.height + this.size) {
                    return false; // Remove pumpkin
                }
                return true;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Draw pumpkin body with gradient
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size/2);
                gradient.addColorStop(0, '#FF8A50');
                gradient.addColorStop(1, '#FF6B35');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Add pumpkin lines
                ctx.strokeStyle = '#E55100';
                ctx.lineWidth = 2;
                for (let i = 0; i < 6; i++) {
                    ctx.beginPath();
                    const angle = (i * Math.PI) / 3;
                    ctx.moveTo(Math.cos(angle) * this.size/3, Math.sin(angle) * this.size/3);
                    ctx.lineTo(Math.cos(angle) * this.size/2, Math.sin(angle) * this.size/2);
                    ctx.stroke();
                }
                
                // Draw eyes
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.moveTo(-this.size/4, -this.size/6);
                ctx.lineTo(-this.size/3, this.size/8);
                ctx.lineTo(-this.size/6, this.size/8);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.size/4, -this.size/6);
                ctx.lineTo(this.size/6, this.size/8);
                ctx.lineTo(this.size/3, this.size/8);
                ctx.closePath();
                ctx.fill();
                
                // Draw mouth
                ctx.beginPath();
                ctx.moveTo(-this.size/4, this.size/4);
                ctx.lineTo(-this.size/6, this.size/3);
                ctx.lineTo(0, this.size/4);
                ctx.lineTo(this.size/6, this.size/3);
                ctx.lineTo(this.size/4, this.size/4);
                ctx.lineTo(0, this.size/3);
                ctx.closePath();
                ctx.fill();
                
                // Draw stem
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(-this.size/8, -this.size/2, this.size/4, this.size/4);
                
                ctx.restore();
            }

            isClicked(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                return Math.sqrt(dx * dx + dy * dy) < this.size/2;
            }
        }

        // Draw background
        function drawBackground() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw some spooky clouds
            ctx.fillStyle = '#16213e';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc(100 + i * 120, 50 + Math.sin(Date.now() * 0.001 + i) * 10, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Spawn new pumpkin
        function spawnPumpkin() {
            const x = Math.random() * (canvas.width - PUMPKIN_SIZE) + PUMPKIN_SIZE/2;
            pumpkins.push(new Pumpkin(x, -PUMPKIN_SIZE/2));
        }

        // Game loop
        function gameUpdate() {
            if (!gameRunning) return;
            
            drawBackground();
            
            // Spawn pumpkins
            const currentTime = Date.now();
            if (currentTime - lastPumpkinSpawn > SPAWN_RATE) {
                spawnPumpkin();
                lastPumpkinSpawn = currentTime;
            }
            
            // Update and draw pumpkins
            for (let i = pumpkins.length - 1; i >= 0; i--) {
                const pumpkin = pumpkins[i];
                
                if (!pumpkin.update()) {
                    // Pumpkin fell off screen
                    if (!pumpkin.clicked) {
                        missed++;
                        document.getElementById('missed').innerText = missed;
                        
                        // Game over if too many missed
                        if (missed >= MAX_MISSED) {
                            endGame("Too many pumpkins missed!");
                            return;
                        }
                    }
                    pumpkins.splice(i, 1);
                } else {
                    pumpkin.draw();
                }
            }
            
            // Display game info
            ctx.fillStyle = 'white';
            ctx.font = '16px Arial';
            ctx.fillText(`Pumpkins: ${pumpkins.length} | Level: ${difficultyLevel}`, 10, canvas.height - 10);
            
            requestAnimationFrame(gameUpdate);
        }

        // End game function
        function endGame(reason = "Time's up!") {
            gameRunning = false;
            if (gameLoop) clearInterval(gameLoop);
            startBtn.disabled = false;
            submitBtn.disabled = false;
            status.innerText = `Game Over! ${reason} Final Score: ${score}`;
            pumpkins = []; // Clear all pumpkins
        }

        // Game Logic - Click handling
        canvas.addEventListener('click', (event) => {
            if (!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            // Check if any pumpkin was clicked
            for (let i = pumpkins.length - 1; i >= 0; i--) {
                const pumpkin = pumpkins[i];
                if (!pumpkin.clicked && pumpkin.isClicked(mouseX, mouseY)) {
                    pumpkin.clicked = true;
                    score++;
                    document.getElementById('score').innerText = score;
                    
                    // Update difficulty
                    updateDifficulty();
                    
                    // Create explosion effect
                    createExplosion(pumpkin.x, pumpkin.y);
                    
                    // Remove pumpkin
                    pumpkins.splice(i, 1);
                    break;
                }
            }
        });

        // Explosion effect
        function createExplosion(x, y) {
            const particles = [];
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 8,
                    vy: (Math.random() - 0.5) * 8,
                    life: 20
                });
            }
            
            function animateParticles() {
                ctx.fillStyle = '#FFD700';
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    
                    ctx.globalAlpha = p.life / 20;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
                ctx.globalAlpha = 1;
                
                if (particles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            }
            animateParticles();
        }

        startBtn.addEventListener('click', () => {
            if (!gameRunning) {
                // Reset game state
                score = 0;
                missed = 0;
                time = 30;
                pumpkins = [];
                lastPumpkinSpawn = 0;
                difficultyLevel = 1;
                PUMPKIN_SPEED = 2;
                SPAWN_RATE = 1200;
                
                // Update UI
                document.getElementById('score').innerText = score;
                document.getElementById('missed').innerText = missed;
                document.getElementById('time').innerText = time;
                status.innerText = '';
                
                // Start game
                gameRunning = true;
                startBtn.disabled = true;
                submitBtn.disabled = true;
                
                // Start game loop
                gameUpdate();
                
                // Start timer
                const timer = setInterval(() => {
                    time--;
                    document.getElementById('time').innerText = time;
                    if (time <= 0) {
                        clearInterval(timer);
                        endGame();
                    }
                }, 1000);
            }
        });

        // Wallet Connection
        connectBtn.addEventListener('click', async () => {
            if (window.ethereum) {
                try {
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    signer = provider.getSigner();
                    contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                    status.innerText = 'Wallet connected!';
                    connectBtn.disabled = true;
                    await loadLeaderboard();
                } catch (err) {
                    status.innerText = 'Connection failed: ' + err.message;
                }
            } else {
                status.innerText = 'Install MetaMask!';
            }
        });

        // Submit Score
        submitBtn.addEventListener('click', async () => {
            if (contract && score > 0) {
                try {
                    status.innerText = 'Submitting...';
                    const tx = await contract.submitScore(score);
                    await tx.wait();
                    status.innerText = 'Score submitted to Somnia!';
                    await loadLeaderboard();
                } catch (err) {
                    status.innerText = 'Submission failed: ' + err.message;
                }
            }
        });

        // Load Leaderboard
        async function loadLeaderboard() {
            if (contract) {
                const readContract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, somniaProvider); // Read-only
                const [players, scores] = await readContract.getLeaderboard(5);
                leaderboardList.innerHTML = '';
                for (let i = 0; i < players.length; i++) {
                    if (scores[i] > 0) {
                        const li = document.createElement('li');
                        li.innerText = `${players[i].slice(0,6)}...${players[i].slice(-4)}: ${scores[i]} candies`;
                        leaderboardList.appendChild(li);
                    }
                }
            }
        }

        // Initialize the game when page loads
        window.addEventListener('load', () => {
            drawBackground(); // Draw initial background
        });
        
        // Draw initial background
        drawBackground();
    </script>
</body>
</html>